from tokens import *

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens  # The list of tokens generated by the lexer
        self.current_token = None  # The current token being processed
        self.next_token()  # Advance to the first token

    def next_token(self):
        # Move to the next token in the list
        if len(self.tokens) > 0:
            self.current_token = self.tokens[0]
            self.tokens = self.tokens[1:]
        else:
            self.current_token = None

    def parse(self):
        # Parse the tokens and generate the AST
        try:
            return self.statements()
        except Exception as e:
            raise SyntaxError(f"Syntax error: {e}")

    def statements(self):
        # Parse multiple statements
        statements = []
        while self.current_token is not None:
            if self.current_token.type == TT_KEYWORD and self.current_token.value == 'Defun':
                statements.append(self.function_definition())
            else:
                statements.append(self.expression())
        return {'type': 'Statements', 'statements': statements}

    def function_definition(self):
        # Parse a function definition
        self.next_token()
        if self.current_token is None:
            raise Exception("Expected function name after 'Defun'")
        func_name = self.current_token.value
        self.next_token()
        if self.current_token is None or self.current_token.type != TT_LPAREN:
            raise Exception("Expected '(' after function name")
        self.next_token()
        args = []
        while self.current_token is not None and self.current_token.type == TT_IDENTIFIER:
            args.append(self.current_token.value)
            self.next_token()
            if self.current_token is not None and self.current_token.type == TT_COMMA:
                self.next_token()
        if self.current_token is None or self.current_token.type != TT_RPAREN:
            raise Exception("Expected ')' after argument list")
        self.next_token()
        # Here, we allow the function body to start on a new line or after ')'
        if self.current_token is None or self.current_token.type not in (TT_LPAREN, TT_IDENTIFIER, TT_INT):
            raise Exception("Expected function body after ')'")

        body = self.expression()
        return {'type': 'FunctionDef', 'name': func_name, 'arguments': args, 'body': body}

    def expression(self):
        # Parse a generic expression
        node = self.boolean_expr()
        return node

    def boolean_expr(self):
        node = self.comparison()

        while self.current_token is not None and self.current_token.type in (TT_AND, TT_OR):
            token = self.current_token
            self.next_token()
            node = {'type': 'BinaryOp', 'operator': token.type, 'left': node, 'right': self.comparison()}

        return node

    def comparison(self):
        # Parse comparison expressions (e.g., >, <, ==, !=)
        node = self.term()
        while self.current_token is not None and self.current_token.type in (TT_EQ, TT_NEQ, TT_GT, TT_LT, TT_GTE, TT_LTE):
            token = self.current_token
            self.next_token()
            node = {'type': 'BinaryOp', 'operator': token.type, 'left': node, 'right': self.term()}
        return node

    def term(self):
        # Parse terms (e.g., addition, subtraction)
        node = self.factor()
        while self.current_token is not None and self.current_token.type in (TT_PLUS, TT_MINUS):
            token = self.current_token
            self.next_token()
            node = {'type': 'BinaryOp', 'operator': token.type, 'left': node, 'right': self.factor()}
        return node

    def factor(self):
        # Parse factors (e.g., multiplication, division)
        node = self.unary()
        while self.current_token is not None and self.current_token.type in (TT_MUL, TT_DIV, TT_MOD):
            token = self.current_token
            self.next_token()
            node = {'type': 'BinaryOp', 'operator': token.type, 'left': node, 'right': self.unary()}
        return node

    def unary(self):
        # Parse unary operations (e.g., negation)
        if self.current_token is not None and self.current_token.type in (TT_NOT, TT_MINUS):
            token = self.current_token
            self.next_token()
            return {'type': 'UnaryOp', 'operator': token.type, 'operand': self.unary()}
        else:
            return self.primary()

    def primary(self):
        # Parse primary expressions (e.g., literals, variables, function calls)
        token = self.current_token
        if token is None:
            raise Exception("Unexpected end of input")

        # Handle integer literals
        if token.type == TT_INT:
            self.next_token()
            return {'type': 'Literal', 'value': token.value}

        # Handle boolean literals
        elif token.type == 'Literal' and isinstance(token.value, bool):
            self.next_token()
            return {'type': 'Literal', 'value': token.value}

        # Handle expressions in parentheses
        elif token.type == TT_LPAREN:
            self.next_token()
            expr = self.expression()
            if self.current_token is None or self.current_token.type != TT_RPAREN:
                raise Exception("Expected ')'")
            self.next_token()
            return expr

        # Handle variable names and function calls
        elif token.type == TT_IDENTIFIER:
            self.next_token()
            if self.current_token is not None and self.current_token.type == TT_LPAREN:
                args = []
                self.next_token()
                while self.current_token is not None and self.current_token.type != TT_RPAREN:
                    args.append(self.expression())
                    if self.current_token is not None and self.current_token.type == TT_COMMA:
                        self.next_token()
                if self.current_token is None or self.current_token.type != TT_RPAREN:
                    raise Exception("Expected ')'")  # Ensure ')' closes the argument list
                self.next_token()
                return {'type': 'FunctionCall', 'name': token.value, 'arguments': args}
            else:
                return {'type': 'Variable', 'name': token.value}

        # Handle lambda expressions
        elif token.type == TT_KEYWORD and token.value == 'Lambd':
            self.next_token()
            param = self.current_token.value
            self.next_token()
            if self.current_token is None or self.current_token.type != TT_DOT:
                raise Exception("Expected '.' in lambda expression")
            self.next_token()
            body = self.expression()
            return {'type': 'Lambda', 'param': param, 'body': body}

        # Handle unexpected tokens
        else:
            raise Exception(f"Unexpected token: {token}")
