from tokens import *


class Interpreter:
    def __init__(self, ast, env=None):
        self.ast = ast  # The AST generated by the parser
        self.env = env if env is not None else {}  # The environment (variable/function definitions)

    def evaluate(self, node=None, env=None):
        if node is None:
            node = self.ast
        if env is None:
            env = self.env

        if node['type'] == 'Statements':
            result = None
            for statement in node['statements']:
                result = self.evaluate(statement, env)
            return result

        elif node['type'] == 'Literal':
            return node['value']

        elif node['type'] == 'BinaryOp':
            left_val = self.evaluate(node['left'], env)
            if node['operator'] == TT_OR and left_val:
                return True
            right_val = self.evaluate(node['right'], env)
            return self.evaluate_binary_op(node['operator'], left_val, right_val)

        elif node['type'] == 'UnaryOp':
            operand_val = self.evaluate(node['operand'], env)
            if node['operator'] == TT_NOT:
                return not operand_val
            elif node['operator'] == TT_MINUS:
                return -operand_val

        elif node['type'] == 'Variable':
            if node['name'] in env:
                return env[node['name']]
            elif node['name'] == 'True':
                return True
            elif node['name'] == 'False':
                return False
            else:
                raise Exception(f"Undefined variable: {node['name']}")

        elif node['type'] == 'FunctionDef':
            env[node['name']] = node
            return None  # No need to return anything when defining a function

        elif node['type'] == 'FunctionCall':
            func = self.evaluate({'type': 'Variable', 'name': node['name']}, env)
            if not func:
                raise Exception(f"Undefined function: {node['name']}")
            if func['type'] == 'Lambd':
                result = self.apply_lambda(func, node['arguments'], env)
                # Handle the case where the result is another lambda function
                while isinstance(result, dict) and result['type'] == 'Lambd' and len(node['arguments']) > 1:
                    node['arguments'].pop(0)
                    result = self.apply_lambda(result, node['arguments'], env)
                return result
            elif func['type'] == 'FunctionDef':
                new_env = env.copy()
                for i, arg in enumerate(func['arguments']):
                    new_env[arg] = self.evaluate(node['arguments'][i], env)
                return self.evaluate(func['body'], new_env)
            else:
                raise Exception(f"Unexpected function type: {func['type']}")

        elif node['type'] == 'Lambd':
            # When a lambda is encountered, return a function that can be called
            return {
                'type': 'Lambd',
                'param': node['param'],
                'body': node['body'],
                'env': env  # Capture the environment where the lambda was defined
            }
        else:
            raise Exception(f"Unexpected node type: {node['type']}")

    def apply_lambda(self, func, args, env):
        new_env = func['env'].copy()  # Create a new environment based on where the lambda was defined
        new_env[func['param']] = self.evaluate(args[0], env)  # Bind the argument to the lambda's parameter
        return self.evaluate(func['body'], new_env)  # Evaluate the lambda's body in the new environment

    def evaluate_binary_op(self, operator, left_val, right_val):
        if operator == TT_AND:
            return left_val and right_val
        elif operator == TT_OR:
            return left_val or right_val
        elif operator == TT_PLUS:
            return left_val + right_val
        elif operator == TT_MINUS:
            return left_val - right_val
        elif operator == TT_MUL:
            return left_val * right_val
        elif operator == TT_DIV:
            return left_val // right_val
        elif operator == TT_MOD:
            return left_val % right_val
        elif operator == TT_EQ:
            return left_val == right_val
        elif operator == TT_NEQ:
            return left_val != right_val
        elif operator == TT_GT:
            return left_val > right_val
        elif operator == TT_LT:
            return left_val < right_val
        elif operator == TT_GTE:
            return left_val >= right_val
        elif operator == TT_LTE:
            return left_val <= right_val
        else:
            raise Exception(f"Unexpected operator: {operator}")
